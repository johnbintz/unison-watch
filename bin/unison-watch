#!/usr/bin/env ruby

require 'Qt4'
require 'thread'
require 'atomic'
require 'thor'

require 'unison/profile'

class UnisonWatcher < Qt::Application
  TRANSFER_LOG = '~/unison.log'
  SYNC_CHECK_COUNT = 600
  SYNC_CHECK_TIME = 0.1

  def initialize(profiles, *args)
    super(*args)

    @profiles = profiles
    @queue = Atomic.new([])

    @sync_now = false
    @exiting = false
    @active = true
  end

  def <<(dirs)
    @queue.update { |q| q += [ dirs ].flatten ; q }
  end

  def processed_profiles
    @processed_profiles ||= Unison::Profile.process(@profiles)
  end

  def watch
    require 'rbconfig'

    watcher = Thread.new do
      while !Thread.current[:app]; sleep 0.1; end

      begin
        @watch = nil

        case RbConfig::CONFIG['host_os']
        when /darwin/
          require 'rb-fsevent'
          @watch = FSEvent.new
          @watch.watch Thread.current[:paths], :latency => 0.1 do |directories|
            Thread.current[:app] << directories
          end
        when /linux/
          require 'rb-inotify'
          @watch = INotify::Notifier.new
          Thread.current[:paths].each do |path|
            FileUtils.mkdir_p path

            @watch.watch path, :recursive, :modify, :create, :delete do |event|
              Thread.current[:app] << event.absolute_name
            end
          end
        end

        @watch.run
      rescue => e
        puts e.message
        puts e.backtrace.join("\n")
        exit
      end
    end

    watcher[:paths] = processed_profiles.collect(&:paths_with_local_root).flatten
    watcher[:app] = self
  end

  def update_status(status)
    new_status = Qt::Action.new(status, @menu)
    new_status.enabled = false
    @menu.insertAction(@active_status, new_status)
    @menu.removeAction(@status)

    @status = new_status
  end

  def menu
    @menu = Qt::Menu.new

    @current_text = 'Unison watch idle.'

    @status = Qt::Action.new(@status_text, @menu)
    @status.enabled = false

    sync_now = Qt::Action.new("Sync now", @menu)
    sync_now.connect(SIGNAL :triggered) { @sync_now = true }

    @active_status = Qt::Action.new("Pause syncing", @menu)
    @active_status.connect(SIGNAL :triggered) { toggle_status }

    @current_log_size = File.size(File.expand_path(TRANSFER_LOG))

    @fileview = Qt::TextEdit.new
    @fileview.plainText = "Watching for changes..."
    @fileview.readOnly = true
    @fileview.resize 800, 600
    @fileview.connect(SIGNAL :textChanged) { @fileview.moveCursor Qt::TextCursor::End }

    @log = Qt::Action.new("View transfer log", @menu)
    @log.connect(SIGNAL :triggered) { @fileview.show }

    quit = Qt::Action.new("Quit", @menu)
    quit.connect(SIGNAL :triggered) { @exiting = true }

    @menu.addAction @active_status
    @menu.addAction sync_now
    @menu.addSeparator
    @menu.addAction @log
    @menu.addAction quit

    @current_text = 'Unison watch idle.'
    update_status @current_text

    @menu
  end

  def update_ui
    if @current_icon != @prior_icon
      if !@icons[@current_icon]
        @icons[@current_icon] = Qt::Icon.new(File.expand_path("../../assets/#{@current_icon}.png", __FILE__))
        @icons["large-#{@current_icon}"] = Qt::Icon.new(File.expand_path("../../assets/large-#{@current_icon}.png", __FILE__))
      end

      @icon.icon = @icons[@current_icon]
      self.windowIcon = @icons["large-#{@current_icon}"]
      @icon.toolTip = "Unison Agent\nUsing #{@profiles.join(', ')} profile"
      if !@prior_icon
        @icon.show
      end

      @prior_icon = @current_icon
    end

    if @current_text!= @prior_text
      update_status @current_text

      @prior_text = @current_text
    end

    processEvents
  end

  def ui
    @icon = Qt::SystemTrayIcon.new
    @icon.contextMenu = menu

    toggle_status true
    @prior_icon = nil
    @prior_text = nil

    @icons = {}

    @remote_sync_check = SYNC_CHECK_COUNT

    while !@exiting
      check

      update_ui

      sleep SYNC_CHECK_TIME
    end
  end

  def start
    self.objectName = "cats"

    watch
    ui
  end

  def check
    begin
      if @active && (@queue.value.length > 0 || @remote_sync_check == 0 || @sync_now)
        dir = nil

        @current_text = "Syncing..."

        @done = false

        runner = Thread.new do
          @profiles.each do |profile|
            system %{bash -c 'unison -log -logfile #{TRANSFER_LOG} -batch #{profile}'}
          end
          @done = true
        end

        index = 0
        while !@done
          @current_icon = "working-#{index + 1}"
          File.open(File.expand_path(TRANSFER_LOG), 'r') { |fh|
            fh.seek(@current_log_size)
            @fileview.plainText = fh.read
          }

          update_ui

          break if @done

          sleep 0.25
          index = (index + 1) % 2
        end

        @current_icon = 'idle'

        @remote_sync_check = SYNC_CHECK_COUNT
        @sync_now = false
        @queue.update { [] }

        File.open(File.expand_path(TRANSFER_LOG), 'r') { |fh|
          fh.seek(@current_log_size)
          @fileview.plainText = fh.read
        }
      end
    rescue => e
      puts e.message
      puts e.backtrace.join("\n")
      exit
    end

    @remote_sync_check -= 1

    if @active
      @current_text = "Next check in #{sprintf("%.0d", SYNC_CHECK_TIME * @remote_sync_check)} secs."
    else
      @current_text = "Syncing paused."

      @remote_sync_check = SYNC_CHECK_COUNT
    end
  end

  def toggle_status(set = nil)
    @active = set || !@active

    @active_status.text = @active ? "Pause syncing" : "Resume syncing"
    @current_icon = @active ? 'idle' : 'paused'
  end
end

class UnisonCLI < Thor
  desc 'start profile <profile> ...', 'Run Unison Watch using the provided profiles'
  def start(*profiles)
    UnisonWatcher.new(profiles, ARGV).start
  end

  default_task :run

  def method_missing(*args)
    start(*args)
  end
end

UnisonCLI.start

